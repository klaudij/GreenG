import {
  require_child_process,
  require_fs,
  require_os,
  require_path,
  require_src2 as require_src,
  require_url,
  require_util
} from "./chunk-SYB4AQMS.js";
import {
  __commonJS,
  __require
} from "./chunk-7FP5O474.js";

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/is-docker/index.js"(exports, module) {
    "use strict";
    var fs = require_fs();
    var isDocker;
    function hasDockerEnv() {
      try {
        fs.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/is-wsl/index.js"(exports, module) {
    "use strict";
    var os = require_os();
    var fs = require_fs();
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module.exports = isWsl;
    } else {
      module.exports = isWsl();
    }
  }
});

// node_modules/open/index.js
var require_open = __commonJS({
  "node_modules/open/index.js"(exports, module) {
    "use strict";
    var { promisify } = require_util();
    var path = require_path();
    var childProcess = require_child_process();
    var fs = require_fs();
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var pAccess = promisify(fs.access);
    var pReadFile = promisify(fs.readFile);
    var localXdgOpenPath = path.join(__dirname, "xdg-open");
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await pAccess(configFilePath, fs.constants.F_OK);
          isConfigFileExists = true;
        } catch (_) {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await pReadFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /root\s*=\s*(.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint[1].trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : mountPoint + "/";
        return mountPoint;
      };
    })();
    module.exports = async (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      options = {
        wait: false,
        background: false,
        allowNonzeroExitCode: false,
        ...options
      };
      let command;
      let { app } = options;
      let appArguments = [];
      const cliArguments = [];
      const childProcessOptions = {};
      if (Array.isArray(app)) {
        appArguments = app.slice(1);
        app = app[0];
      }
      if (process.platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (process.platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          appArguments.unshift(target);
        } else {
          encodedArguments.push(`"${target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await pAccess(localXdgOpenPath, fs.constants.X_OK);
            exeLocalXdgOpen = true;
          } catch (_) {
          }
          const useSystemXdgOpen = process.versions.electron || process.platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      cliArguments.push(target);
      if (process.platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
  }
});

// node_modules/@google-cloud/local-auth/node_modules/arrify/index.js
var require_arrify = __commonJS({
  "node_modules/@google-cloud/local-auth/node_modules/arrify/index.js"(exports, module) {
    "use strict";
    var arrify = (value) => {
      if (value === null || value === void 0) {
        return [];
      }
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return [value];
      }
      if (typeof value[Symbol.iterator] === "function") {
        return [...value];
      }
      return [value];
    };
    module.exports = arrify;
  }
});

// node_modules/server-destroy/index.js
var require_server_destroy = __commonJS({
  "node_modules/server-destroy/index.js"(exports, module) {
    module.exports = enableDestroy;
    function enableDestroy(server) {
      var connections = {};
      server.on("connection", function(conn) {
        var key = conn.remoteAddress + ":" + conn.remotePort;
        connections[key] = conn;
        conn.on("close", function() {
          delete connections[key];
        });
      });
      server.destroy = function(cb) {
        server.close(cb);
        for (var key in connections)
          connections[key].destroy();
      };
    }
  }
});

// node_modules/@google-cloud/local-auth/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@google-cloud/local-auth/build/src/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authenticate = void 0;
    var google_auth_library_1 = require_src();
    var http = require_http();
    var url_1 = require_url();
    var opn = require_open();
    var arrify = require_arrify();
    var destroyer = require_server_destroy();
    var invalidRedirectUri = `The provided keyfile does not define a valid
redirect URI. There must be at least one redirect URI defined, and this sample
assumes it redirects to 'http://localhost:3000/oauth2callback'.  Please edit
your keyfile, and add a 'redirect_uris' section.  For example:

"redirect_uris": [
  "http://localhost:3000/oauth2callback"
]
`;
    function isAddressInfo(addr) {
      return addr.port !== void 0;
    }
    async function authenticate(options) {
      var _a;
      if (!options || !options.keyfilePath || typeof options.keyfilePath !== "string") {
        throw new Error("keyfilePath must be set to the fully qualified path to a GCP credential keyfile.");
      }
      const keyFile = __require(options.keyfilePath);
      const keys = keyFile.installed || keyFile.web;
      if (!keys.redirect_uris || keys.redirect_uris.length === 0) {
        throw new Error(invalidRedirectUri);
      }
      const redirectUri = new url_1.URL((_a = keys.redirect_uris[0]) !== null && _a !== void 0 ? _a : "http://localhost");
      if (redirectUri.hostname !== "localhost") {
        throw new Error(invalidRedirectUri);
      }
      const client = new google_auth_library_1.OAuth2Client({
        clientId: keys.client_id,
        clientSecret: keys.client_secret
      });
      return new Promise((resolve, reject) => {
        const server = http.createServer(async (req, res) => {
          try {
            const url = new url_1.URL(req.url, "http://localhost:3000");
            if (url.pathname !== redirectUri.pathname) {
              res.end("Invalid callback URL");
              return;
            }
            const searchParams = url.searchParams;
            if (searchParams.has("error")) {
              res.end("Authorization rejected.");
              reject(new Error(searchParams.get("error")));
              return;
            }
            if (!searchParams.has("code")) {
              res.end("No authentication code provided.");
              reject(new Error("Cannot read authentication code."));
              return;
            }
            const code = searchParams.get("code");
            const { tokens } = await client.getToken({
              code,
              redirect_uri: redirectUri.toString()
            });
            client.credentials = tokens;
            resolve(client);
            res.end("Authentication successful! Please return to the console.");
          } catch (e) {
            reject(e);
          } finally {
            server.destroy();
          }
        });
        let listenPort = 3e3;
        if (keyFile.installed) {
          listenPort = 0;
        } else if (redirectUri.port !== "") {
          listenPort = Number(redirectUri.port);
        }
        server.listen(listenPort, () => {
          const address = server.address();
          if (isAddressInfo(address)) {
            redirectUri.port = String(address.port);
          }
          const scopes = arrify(options.scopes || []);
          const authorizeUrl = client.generateAuthUrl({
            redirect_uri: redirectUri.toString(),
            access_type: "offline",
            scope: scopes.join(" ")
          });
          opn(authorizeUrl, { wait: false }).then((cp) => cp.unref());
        });
        destroyer(server);
      });
    }
    exports.authenticate = authenticate;
  }
});
export default require_src2();
//# sourceMappingURL=@google-cloud_local-auth.js.map
